#!/usr/bin/env python3

#------------------------------------------------------------------------
# isobar: ex-basics
# 
# Example of some basic functionality: Pattern transformations,
# sequences, scales, stochastic functions, scheduling and mapping.
#------------------------------------------------------------------------

from isobar_ext import *

#------------------------------------------------------------------------
# Turn on some basic logging output. 
#------------------------------------------------------------------------
import logging

def main():
    #------------------------------------------------------------------------
    # Create a geometric series on a minor scale.
    # PingPong plays the series forward then backward. PLoop loops forever.
    #------------------------------------------------------------------------
    arpeggio = PSeries(0, 2, 6)
    arpeggio = PDegree(arpeggio, Scale.minor) + 72
    arpeggio = PPingPong(arpeggio)
    arpeggio = PLoop(arpeggio)

    #------------------------------------------------------------------------
    # Create a velocity sequence, with emphasis every 4th note,
    # plus a random walk to create gradual dynamic changes.
    # Amplitudes are in the MIDI velocity range (0..127).
    #------------------------------------------------------------------------
    amplitude = PSequence([50, 35, 25, 35]) + PBrown(0, 1, -20, 20)

    #------------------------------------------------------------------------
    # Create a repeating sequence with scalar transposition:
    # [ 36, 38, 43, 39, 36, 38, 43, 39, ... ]
    #------------------------------------------------------------------------
    bassline = PSequence([0, 2, 7, 3]) + 36

    #------------------------------------------------------------------------
    # Repeat each note 3 times, and transpose each into a different octave
    # [ 36, 48, 60, 38, 50, 62, ... ]
    #------------------------------------------------------------------------
    bassline = PStutter(bassline, 3) + PSequence([0, 12, 24])

    #------------------------------------------------------------------------
    # A Timeline schedules events at a specified tempo. By default, events
    # are send to the system's default MIDI output.
    #------------------------------------------------------------------------
    timeline = Timeline(120)

    #------------------------------------------------------------------------
    # Schedule events, with properties generated by the Pattern objects.
    #------------------------------------------------------------------------
    timeline.schedule({
        "note": arpeggio,
        "duration": 0.25,
        "amplitude": amplitude
    })
    timeline.schedule({
        "note": bassline,
        "duration": 1
    })

    timeline.run()


    #========================================================================
    # A Timeline schedules events at a specified tempo. Events can be sent
    # to mutli track midi file.
    #------------------------------------------------------------------------
    output = MidiOutputDevice()
    filename = "output.mid"
    midifile = MidiFileOutputDevice(filename)
    timeline = Timeline(120, midifile)

    #------------------------------------------------------------------------
    # Schedule events, that will be added to track 1 and track 2 of midifile.
    # This option shows 2 `schedule` functions used
    #------------------------------------------------------------------------
    timeline.schedule({
        "note": arpeggio,
        "duration": 0.25,
        "amplitude": amplitude
    }, sel_track_idx=0)

    timeline.schedule({
        "note": bassline,
        "duration": 1
    }, sel_track_idx=0)

    timeline.run()

    #------------------------------------------------------------------------
    # Schedule events, that will be added to track 1 and track 2 of midifile.
    # This option shows usage of list as argument to `schedule` function.
    # Combination of channel and track_idx is used to calculate real tack idx
    # Each time specific combination is used
    # it will get the same real track idx.
    #------------------------------------------------------------------------

    events_1 = {
        EVENT_NOTE: PSequence(sequence=[50, 52, 55, 57], repeats=1)
        , EVENT_DURATION: PSequence(sequence=[0.5, 1, 1, 1.5], repeats=1)
        , EVENT_CHANNEL: 0
        , EVENT_ACTION_ARGS: {'track_idx': 0}
    }

    events_2 = {
        EVENT_NOTE: PSequence(sequence=[75, 69, 72, 66], repeats=1)
        , EVENT_DURATION: PSequence(sequence=[1, 1, 1, 1], repeats=1)
        , EVENT_CHANNEL: 2
        , EVENT_ACTION_ARGS: {'track_idx': 5}
    }

    event_list = [events_1.copy(), events_2.copy()]

    timeline.schedule(event_list)
    timeline.run()

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format="[%(asctime)s] %(message)s")
    main()